{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/wangyingxu/Desktop/duke/651project/prev version/risk-team4-front-end/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { compute as e } from \"compute-scroll-into-view\";\nvar o = function o(e) {\n    return \"object\" == typeof e && \"function\" == typeof e.behavior;\n  },\n  t = function t(e) {\n    return !1 === e ? {\n      block: \"end\",\n      inline: \"nearest\"\n    } : function (e) {\n      return e === Object(e) && 0 !== Object.keys(e).length;\n    }(e) ? e : {\n      block: \"start\",\n      inline: \"nearest\"\n    };\n  };\nvar n = function n(e) {\n  for (var o = e; o && o.parentNode;) {\n    if (o.parentNode === document) return !0;\n    o = o.parentNode instanceof ShadowRoot ? o.parentNode.host : o.parentNode;\n  }\n  return !1;\n};\nfunction r(r, i) {\n  if (!r.isConnected || !n(r)) return;\n  if (o(i)) return i.behavior(e(r, i));\n  var l = \"boolean\" == typeof i || null == i ? void 0 : i.behavior;\n  var _iterator = _createForOfIteratorHelper(e(r, t(i))),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _step.value,\n        _o = _step$value.el,\n        _n = _step$value.top,\n        a = _step$value.left;\n      _o.scroll({\n        top: _n,\n        left: a,\n        behavior: l\n      });\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\nexport { r as default };","map":{"version":3,"names":["o","e","behavior","t","block","inline","Object","keys","length","n","parentNode","document","ShadowRoot","host","r","i","isConnected","l","_iterator","_createForOfIteratorHelper","_step","s","done","_step$value","value","el","top","a","left","scroll","err","f","default"],"sources":["../src/index.ts"],"sourcesContent":["import { compute } from 'compute-scroll-into-view'\nimport type {\n  Options as BaseOptions,\n  ScrollAction,\n} from 'compute-scroll-into-view'\n\n/** @public */\nexport type Options<T = unknown> =\n  | StandardBehaviorOptions\n  | CustomBehaviorOptions<T>\n\n/**\n * Only scrolls if the `node` is partially out of view:\n * ```ts\n * scrollIntoView(node, { scrollMode: 'if-needed' })\n * ```\n * Skips scrolling `overflow: hidden` elements:\n * ```ts\n * scrollIntoView(node, { skipOverflowHiddenElements: true })\n * ```\n * When scrolling is needed do the least and smoothest scrolling possible:\n * ```ts\n * scrollIntoView(node, {\n *   behavior: 'smooth',\n *   scrollMode: 'if-needed',\n *   block: 'nearest',\n *   inline: 'nearest',\n * })\n * ```\n * @public\n */\nexport interface StandardBehaviorOptions extends BaseOptions {\n  /**\n   * @defaultValue 'auto\n   */\n  behavior?: ScrollBehavior\n}\n\n/** @public */\nexport interface CustomBehaviorOptions<T = unknown> extends BaseOptions {\n  behavior: CustomScrollBehaviorCallback<T>\n}\n\n/** @public */\nexport type CustomScrollBehaviorCallback<T = unknown> = (\n  actions: ScrollAction[]\n) => T\n\nlet isStandardScrollBehavior = (\n  options: any\n): options is StandardBehaviorOptions =>\n  options === Object(options) && Object.keys(options).length !== 0\n\nlet isCustomScrollBehavior = <T = unknown>(\n  options: any\n): options is CustomBehaviorOptions<T> =>\n  typeof options === 'object' ? typeof options.behavior === 'function' : false\n\nlet getOptions = (options: any): StandardBehaviorOptions => {\n  // Handle alignToTop for legacy reasons, to be compatible with the spec\n  if (options === false) {\n    return { block: 'end', inline: 'nearest' }\n  }\n\n  if (isStandardScrollBehavior(options)) {\n    // compute.ts ensures the defaults are block: 'center' and inline: 'nearest', to conform to the spec\n    return options\n  }\n\n  // if options = {}, options = true or options = null, based on w3c web platform test\n  return { block: 'start', inline: 'nearest' }\n}\n\n// Determine if the element is part of the document (including shadow dom)\n// Derived from code of Andy Desmarais\n// https://terodox.tech/how-to-tell-if-an-element-is-in-the-dom-including-the-shadow-dom/\nconst isInDocument = (element: Node) => {\n  var currentElement = element\n  while (currentElement && currentElement.parentNode) {\n    if (currentElement.parentNode === document) {\n      return true\n    } else if (currentElement.parentNode instanceof ShadowRoot) {\n      currentElement = (currentElement.parentNode as ShadowRoot).host\n    } else {\n      currentElement = currentElement.parentNode\n    }\n  }\n  return false\n}\n\n/**\n * Scrolls the given element into view, with options for when, and how.\n * Supports the same `options` as [`Element.prototype.scrollIntoView`](https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView) with additions such as `scrollMode`, `behavior: Function` and `skipOverflowHiddenElements`.\n * @public\n */\nfunction scrollIntoView(\n  target: Element,\n  options?: StandardBehaviorOptions | boolean\n): void\n/**\n * Scrolls the given element into view, with options for when, and how.\n * Supports the same `options` as [`Element.prototype.scrollIntoView`](https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView) with additions such as `scrollMode`, `behavior: Function` and `skipOverflowHiddenElements`.\n *\n * You can set the expected return type for `behavior: Function`:\n * ```ts\n * await scrollIntoView<Promise<boolean[]>>(node, {\n *   behavior: async actions => {\n *     return Promise.all(actions.map(\n *       // animate() resolves to `true` if anything was animated, `false` if the element already were in the end state\n *       ({ el, left, top }) => animate(el, {scroll: {left, top}})\n *     ))\n *   }\n * })\n * ```\n * @public\n */\nfunction scrollIntoView<T>(\n  target: Element,\n  options: CustomBehaviorOptions<T>\n): T\nfunction scrollIntoView<T = unknown>(\n  target: Element,\n  options?: StandardBehaviorOptions | CustomBehaviorOptions<T> | boolean\n): T | void {\n  // Browsers treats targets that aren't in the dom as a no-op and so should we\n  if (!target.isConnected || !isInDocument(target)) {\n    return\n  }\n\n  if (isCustomScrollBehavior<T>(options)) {\n    return options.behavior(compute(target, options))\n  }\n\n  let behavior = typeof options === 'boolean' ? undefined : options?.behavior\n  for (let { el, top, left } of compute(target, getOptions(options))) {\n    el.scroll({ top, left, behavior })\n  }\n}\n\nexport default scrollIntoView\n"],"mappings":";;AAgDA,IAKIA,CAAA,GACF,SADEA,EACFC,CAAA;IAAA,OAEmB,mBAAZA,CAAA,IAAmD,qBAArBA,CAAA,CAAQC,QAAA;EAAA;EAE3CC,CAAA,GAAc,SAAdA,EAAcF,CAAA;IAAA,QAEA,MAAZA,CAAA,GACK;MAAEG,KAAA,EAAO;MAAOC,MAAA,EAAQ;IAAA,IAZjC,UAAAJ,CAAA;MAAA,OAEAA,CAAA,KAAYK,MAAA,CAAOL,CAAA,KAA4C,MAAhCK,MAAA,CAAOC,IAAA,CAAKN,CAAA,EAASO,MAAA;IAAA,EAavBP,CAAA,IAEpBA,CAAA,GAIF;MAAEG,KAAA,EAAO;MAASC,MAAA,EAAQ;IAAA;EAAA;AAMnC,IAAMI,CAAA,GAAgB,SAAhBA,EAAgBR,CAAA;EAEb,KADP,IAAID,CAAA,GAAiBC,CAAA,EACdD,CAAA,IAAkBA,CAAA,CAAeU,UAAA,GAAY;IAC9C,IAAAV,CAAA,CAAeU,UAAA,KAAeC,QAAA,EACzB;IAEPX,CAAA,GADSA,CAAA,CAAeU,UAAA,YAAsBE,UAAA,GAC5BZ,CAAA,CAAeU,UAAA,CAA0BG,IAAA,GAE1Cb,CAAA,CAAeU,UAEpC;EAAA;EACO;AAAA;AAiCT,SAASI,EACPA,CAAA,EACAC,CAAA;EAGA,KAAKD,CAAA,CAAOE,WAAA,KAAgBP,CAAA,CAAaK,CAAA,GACvC;EAGE,IAAAd,CAAA,CAA0Be,CAAA,GAC5B,OAAOA,CAAA,CAAQb,QAAA,CAASD,CAAA,CAAQa,CAAA,EAAQC,CAAA;EAG1C,IAAIE,CAAA,GAA8B,oBAAZF,CAAA,IAA6C,QAATA,CAAA,QAAZ,IAAqBA,CAAA,CAAAb,QAAA;EAC1D,IAAAgB,SAAA,GAAAC,0BAAA,CAAqBlB,CAAA,CAAQa,CAAA,EAAQX,CAAA,CAAWY,CAAA;IAAAK,KAAA;EAAA;IAAhD,KAAAF,SAAA,CAAAG,CAAA,MAAAD,KAAA,GAAAF,SAAA,CAAAT,CAAA,IAAAa,IAAA,GACP;MAAA,IAAAC,WAAA,GAAAH,KAAA,CAAAI,KAAA;QADSxB,EAAA,GAAAuB,WAAA,CAAFE,EAAA;QAAMhB,EAAA,GAAAc,WAAA,CAAAG,GAAA;QAAKC,CAAA,GAAAJ,WAAA,CAALK,IAAA;MACb5B,EAAA,CAAG6B,MAAA,CAAO;QAAEH,GAAA,EAAAjB,EAAA;QAAKmB,IAAA,EAAAD,CAAA;QAAMzB,QAAA,EAAAe;MAAA,EAE3B;IAF2B;EAE3B,SAAAa,GAAA;IAAAZ,SAAA,CAAAjB,CAAA,CAAA6B,GAAA;EAAA;IAAAZ,SAAA,CAAAa,CAAA;EAAA;AAAA;AAAA,SAAAjB,CAAA,IAAAkB,OAAA"},"metadata":{},"sourceType":"module"}